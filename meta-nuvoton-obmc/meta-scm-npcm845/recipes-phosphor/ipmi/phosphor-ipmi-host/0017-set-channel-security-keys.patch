From f863d22fef6d18583616762cfd602a9a46441a49 Mon Sep 17 00:00:00 2001
From: Joseph Liu <kwliu@nuvoton.com>
Date: Mon, 24 Mar 2025 15:08:25 +0800
Subject: [PATCH] set channel security keys

Upstream-Status: Inappropriate [oe-specific]

Signed-off-by: Stanley Chu <yschu@nuvoton.com>
---
 app/channel.hpp             |  15 ++++
 apphandler.cpp              | 158 ++++++++++++++++++++++++++++++++++++
 include/ipmid/api.h         |   5 ++
 user_channel/user_layer.cpp |  34 ++++++++
 user_channel/user_layer.hpp |   5 ++
 5 files changed, 217 insertions(+)

diff --git a/app/channel.hpp b/app/channel.hpp
index a6b8703d..e9f24c9c 100644
--- a/app/channel.hpp
+++ b/app/channel.hpp
@@ -41,3 +41,18 @@ static constexpr auto conf = "confidentiality";
 static constexpr auto confTag = 0x80;
 
 } // namespace cipher
+
+struct SetChSecurityresp
+{
+   uint8_t LockStatus;
+   uint8_t keys[20];
+}__attribute__((packed));
+
+struct SetChSecurity
+{
+   uint8_t ChannelNum;
+   uint8_t Operation;
+   uint8_t KeyID;
+   uint8_t keys[20];
+}__attribute__((packed));
+
diff --git a/apphandler.cpp b/apphandler.cpp
index 1e320615..e6116999 100644
--- a/apphandler.cpp
+++ b/apphandler.cpp
@@ -67,7 +67,21 @@ using Activation =
 using BMC = sdbusplus::server::xyz::openbmc_project::state::BMC;
 namespace fs = std::filesystem;
 
+#define MAXCH 15
+#define KR 0
+#define KG 1
+#define READ_KEY 0
+#define SET_KEY 1
+#define LOCKKEY 2
+#define NULLSTR "00000000000000000000"
+#define KEYSIZE 20
+#define KR_FILE "/etc/ipmi_kr"
+#define KG_FILE "/etc/ipmi_kg"
+#define KR_LOCK_FILE "/etc/ipmi_kr_locked"
+#define KEYLOCKED 1
+#define KEYUNLOCKED 2
 #ifdef ENABLE_I2C_WHITELIST_CHECK
+
 typedef struct
 {
     uint8_t busId;
@@ -1785,6 +1799,145 @@ ipmi::RspType<std::vector<uint8_t>> ipmiControllerWriteRead(
     return ipmi::responseSuccess(readBuf);
 }
 
+ 
+bool CheckNullValue(uint8_t* keys, uint8_t* testNull)
+{
+        for(int i = 0; i < KEYSIZE ; i++ )
+        {
+            testNull[i] = keys[i]+48;
+        }
+        std::string p (reinterpret_cast<char*>(testNull));
+        if( !strncmp(p.c_str(),NULLSTR,KEYSIZE))
+        {
+                return true;
+        }
+        return false;
+}
+
+/**
+ @brief Implements Set Channel Security Command which can be used for
+ channel security via RMCP+
+**/
+ipmi_ret_t ipmi_set_chan_security_keys(ipmi_netfn_t, ipmi_cmd_t,
+                                    ipmi_request_t request,
+                                    ipmi_response_t response,
+                                    ipmi_data_len_t dataLen,
+                                    ipmi_context_t)
+{
+        std::array<uint8_t,KEYSIZE> keys;
+        std::fill(keys.data(),
+              keys.data() + keys.size(),0);
+        uint8_t testNull[KEYSIZE];
+
+        auto *reqData = reinterpret_cast<SetChSecurity*>(request);
+        auto *resp = reinterpret_cast<SetChSecurityresp*>(response);
+        if( reqData->ChannelNum > MAXCH )
+        {
+                return IPMI_CC_INVALID_FIELD_REQUEST;
+        }
+
+        switch(reqData->Operation)
+        {
+                case READ_KEY:
+                        {
+                                if(*dataLen != 3)
+                                {
+                                        return IPMI_CC_INVALID_FIELD_REQUEST;
+                                }
+                                if(reqData->KeyID != KR && reqData->KeyID != KG)
+                                {
+                                        return IPMI_CC_INVALID_FIELD_REQUEST;
+                                }
+
+                                *dataLen = sizeof(SetChSecurityresp);
+
+                                if(reqData->KeyID == KR && fs::exists(KR_LOCK_FILE))
+                                {
+                                    resp->LockStatus = KEYLOCKED;
+                                    return IPMI_CC_REQ_CANNOT_PERFORM_KEY_LOCKED;
+                                } else
+                                {
+                                    resp->LockStatus = KEYUNLOCKED;
+                                }
+
+                                std::string key_file;
+                                if (reqData->KeyID == KR)
+                                    key_file = KR_FILE;
+                                else
+                                    key_file = KG_FILE;
+                                std::ifstream readkey(key_file, std::ios::in | std::ios::binary);
+                                if (!readkey.is_open())
+                                {
+                                        std::memcpy(resp->keys,&keys,KEYSIZE);
+                                        break;
+                                }
+                                readkey.read(reinterpret_cast<char*>(keys.data()),KEYSIZE);
+                                readkey.close();
+                                std::string p (reinterpret_cast<char*>(keys.data()));
+                                if(!strncmp(p.c_str(),NULLSTR,KEYSIZE))
+                                {
+                                        std::fill(keys.data(),
+                                                        keys.data() + keys.size(),0);
+                                        std::memcpy(resp->keys,&keys,KEYSIZE);
+                                        break;
+                                }
+                                std::memcpy(resp->keys, reinterpret_cast<uint8_t*>(&keys),KEYSIZE);
+                                break;
+                        }
+
+                case SET_KEY:
+                        {
+                                if(( *dataLen - 3 ) >  KEYSIZE)
+                                {
+                                        return IPMI_CC_REQ_TO_MANY_KEY_BYTES;
+                                }
+                                if(( *dataLen - 3 ) <  KEYSIZE)
+                                {
+                                        return IPMI_CC_REQ_INSUFFICIENT_KEY_BYTES;
+                                }
+
+                                if(reqData->KeyID != KR && reqData->KeyID != KG)
+                                {
+                                        return IPMI_CC_INVALID_FIELD_REQUEST;
+                                }
+                                if (reqData->KeyID == KR && fs::exists(KR_LOCK_FILE))
+                                {
+                                        return IPMI_CC_REQ_CANNOT_PERFORM_KEY_LOCKED;
+                                }
+                                std::string key_file;
+                                if (reqData->KeyID == KR)
+                                    key_file = KR_FILE;
+                                else
+                                    key_file = KG_FILE;
+                                *dataLen = 0;
+                                std::ofstream writekey(key_file, std::ios::out | std::ios::trunc);
+                                if(CheckNullValue(reqData->keys,testNull))
+                                {
+                                        writekey.write(reinterpret_cast<char*>(&testNull) , KEYSIZE );
+                                        writekey.close();
+                                        break;
+                                }
+                                writekey.write(reinterpret_cast<char*>(&(reqData->keys)) , KEYSIZE );
+                                writekey.close();
+                                break;
+                        }
+
+		case LOCKKEY :
+                        {
+                                if(reqData->KeyID != KR)
+                                    return IPMI_CC_REQ_KEY_DOES_NOT_MEET_CRITERIA;
+                                resp->LockStatus = KEYLOCKED;
+                                std::ofstream lock_file(KR_LOCK_FILE, std::ios::out | std::ios::trunc);
+                                lock_file.close();
+                                break;
+                        }
+                default :
+                                return IPMI_CC_INVALID_FIELD_REQUEST;
+        }
+
+        return IPMI_CC_OK;
+}
+
 void registerNetFnAppFunctions()
 {
     // <Get Device ID>
@@ -1869,5 +2022,10 @@ void registerNetFnAppFunctions()
     ipmi::registerHandler(ipmi::prioOpenBmcBase, ipmi::netFnApp,
                           ipmi::app::cmdSetSystemInfoParameters,
                           ipmi::Privilege::Admin, ipmiAppSetSystemInfo);
+
+    // <Set Channel Security Keys>
+    ipmi_register_callback(NETFUN_APP, ipmi::app::cmdSetChannelSecurityKeys , NULL,
+                           ipmi_set_chan_security_keys, PRIVILEGE_ADMIN);
+
     return;
 }
diff --git a/include/ipmid/api.h b/include/ipmid/api.h
index fd6fee61..a1a00027 100644
--- a/include/ipmid/api.h
+++ b/include/ipmid/api.h
@@ -108,6 +108,11 @@ enum ipmi_return_codes
     IPMI_WDOG_CC_NOT_INIT = 0x80,
     IPMI_CC_SYSTEM_INFO_PARAMETER_NOT_SUPPORTED = 0x80,
     IPMI_CC_SYSTEM_INFO_PARAMETER_SET_READ_ONLY = 0x82,
+    IPMI_CC_REQ_CANNOT_PERFORM_KEY_LOCKED = 0x80,
+    IPMI_CC_REQ_INSUFFICIENT_KEY_BYTES = 0x81,
+    IPMI_CC_REQ_TO_MANY_KEY_BYTES = 0x82,
+    IPMI_CC_REQ_KEY_DOES_NOT_MEET_CRITERIA = 0x83,
+    IPMI_CC_REQ_KR_IS_NOT_USED = 0x84,
     IPMI_CC_BUSY = 0xC0,
     IPMI_CC_INVALID = 0xC1,
     IPMI_CC_TIMEOUT = 0xC3,
diff --git a/user_channel/user_layer.cpp b/user_channel/user_layer.cpp
index 5a2e7e02..92a13753 100644
--- a/user_channel/user_layer.cpp
+++ b/user_channel/user_layer.cpp
@@ -18,6 +18,14 @@
 
 #include "passwd_mgr.hpp"
 #include "user_mgmt.hpp"
+#include <fstream>
+#include <iostream>
+#define SETZERO 48
+#define KEYSIZE 20
+#define ID_KR 0
+#define ID_KG 1
+#define KR_FILE "/etc/ipmi_kr"
+#define KG_FILE "/etc/ipmi_kg"
 
 namespace
 {
@@ -223,4 +231,30 @@ Cc ipmiUserGetUserPayloadAccess(const uint8_t chNum, const uint8_t userId,
     return ccSuccess;
 }
 
+std::string ipmiGetChannelSecurityKeys(const uint8_t keyId)
+{
+   std::array<uint8_t,20> keys;
+   std::string keyfile;
+
+   if (keyId == ID_KR)
+       keyfile = KR_FILE;
+   else if (keyId == ID_KG)
+       keyfile = KG_FILE;
+   else
+       return "00000000000000000000";
+
+   std::ifstream chsecuritykey(keyfile, std::ios::in | std::ios::binary);
+   if (!chsecuritykey.is_open())
+   {
+            std::fill(keys.data(),
+              keys.data() + keys.size(),SETZERO);
+      std::string p (reinterpret_cast<char*>(keys.data()));
+      return p;
+   }
+   chsecuritykey.read(reinterpret_cast<char*>(keys.data()), KEYSIZE);
+   chsecuritykey.close();
+
+   std::string p (reinterpret_cast<char*>(keys.data()));
+   return p;
+}
 } // namespace ipmi
diff --git a/user_channel/user_layer.hpp b/user_channel/user_layer.hpp
index ad215e39..688b0eec 100644
--- a/user_channel/user_layer.hpp
+++ b/user_channel/user_layer.hpp
@@ -266,5 +266,10 @@ Cc ipmiUserSetUserPayloadAccess(const uint8_t chNum, const uint8_t operation,
  */
 Cc ipmiUserGetUserPayloadAccess(const uint8_t chNum, const uint8_t userId,
                                 PayloadAccess& payloadAccess);
+/** @brief The ipmi get security keys
+ *
+ *  @return 20 byte security
+ */
+std::string ipmiGetChannelSecurityKeys(const uint8_t keyId);
 
 } // namespace ipmi
-- 
2.43.0

